# Стратегия

## Задача

1. Реализовать возможность "действия" с машиной различными способами: купить ("Buy"), продать ("Sell") или сжечь ("Burn"). Возможно, перечень способов будет расширяться.



## Решение с использованием паттерна "Стратегия"

1. Объявить перечисляемый тип способа действия с машиной.
2. Создать класс абстрактный класс стратегии действия ``ActionStrategy``
3. Унаследовать от него конкретные классы стратегий: ``BuyStrategy``, ``SellStrategy``, ``BurnStrategy``
4. Разработать фабричный метод для создания экземпляров классов стратегий дейсвия с автомобилем.
5. Инкапсулировать стратегию дейсвия с автомобилем в родительском классе ``EuropeCars`` с использованием указателя.
6. Дополнить интерфейс класса ``EuropeCars`` функцией для задания стратегии ``InitCar(ActionStrategy*)``.
7. Переписать функцию ``PrintData()`` родительского класса ``EuropeCars``, чтобы она использовала указанную стратегию.

## Краткая характеристика паттерна "Стратегия"

**Паттерн "Стратегия"** определяет семейство алгоритмов, инкапсулирует каждый из них и обеспечивает их взаимозаменяемость. Он позволяет модифицировать алгоритмы независимо от их использования на стороне клиента.

# Шаблонный метод

## Задача

1. Унифицировать структуру алгоритма метода ``PrintData()`` родительского класса ``EuropeCars`` и унаследованных от него классов.
2. Уменьшить количество дублируемого кода в методах ``PrintData()``.

## Решение с использованием паттерна "Шаблонный метод"

1. Зафиксировать общую структуру алгоритма на уровне родительского класса, создав соответствующие абстрактные методы-этапы алгоритма. **Функция ``PrintData()`` перестает быть виртуальной!**
2. Весь повторяющийся код реализовать на уровне родительского класса.
3. Весь специфический для конкретного автомобиля код перенести в реализации методов-этапов на уровне унаследованных классов.

## Краткая характеристика паттерна "Шаблонный метод"

Паттерн "Шаблонный метод" задает "скелет" алгоритма в методе, оставляя определение реализации некоторых шагов унаследованным классам. Эти классы могут переопределять некоторые части алгоритма без изменения его структуры.
